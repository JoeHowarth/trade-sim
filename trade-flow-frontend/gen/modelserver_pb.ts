// @generated by protoc-gen-es v0.0.10 with parameter "target=ts"
// @generated from file modelserver.proto (package modelserver, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";

/**
 * @generated from message modelserver.SubModelReq
 */
export class SubModelReq extends Message<SubModelReq> {
  constructor(data?: PartialMessage<SubModelReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.SubModelReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubModelReq {
    return new SubModelReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubModelReq {
    return new SubModelReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubModelReq {
    return new SubModelReq().fromJsonString(jsonString, options);
  }

  static equals(a: SubModelReq | PlainMessage<SubModelReq> | undefined, b: SubModelReq | PlainMessage<SubModelReq> | undefined): boolean {
    return proto3.util.equals(SubModelReq, a, b);
  }
}

/**
 * @generated from message modelserver.VisualReq
 */
export class VisualReq extends Message<VisualReq> {
  constructor(data?: PartialMessage<VisualReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.VisualReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VisualReq {
    return new VisualReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VisualReq {
    return new VisualReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VisualReq {
    return new VisualReq().fromJsonString(jsonString, options);
  }

  static equals(a: VisualReq | PlainMessage<VisualReq> | undefined, b: VisualReq | PlainMessage<VisualReq> | undefined): boolean {
    return proto3.util.equals(VisualReq, a, b);
  }
}

/**
 * @generated from message modelserver.LatestModelReq
 */
export class LatestModelReq extends Message<LatestModelReq> {
  constructor(data?: PartialMessage<LatestModelReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.LatestModelReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LatestModelReq {
    return new LatestModelReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LatestModelReq {
    return new LatestModelReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LatestModelReq {
    return new LatestModelReq().fromJsonString(jsonString, options);
  }

  static equals(a: LatestModelReq | PlainMessage<LatestModelReq> | undefined, b: LatestModelReq | PlainMessage<LatestModelReq> | undefined): boolean {
    return proto3.util.equals(LatestModelReq, a, b);
  }
}

/**
 * @generated from message modelserver.ModelReq
 */
export class ModelReq extends Message<ModelReq> {
  /**
   * @generated from field: uint64 tick = 1;
   */
  tick = protoInt64.zero;

  constructor(data?: PartialMessage<ModelReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.ModelReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tick", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelReq {
    return new ModelReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelReq {
    return new ModelReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelReq {
    return new ModelReq().fromJsonString(jsonString, options);
  }

  static equals(a: ModelReq | PlainMessage<ModelReq> | undefined, b: ModelReq | PlainMessage<ModelReq> | undefined): boolean {
    return proto3.util.equals(ModelReq, a, b);
  }
}

/**
 * @generated from message modelserver.Model
 */
export class Model extends Message<Model> {
  /**
   * @generated from field: uint64 tick = 1;
   */
  tick = protoInt64.zero;

  /**
   * @generated from field: map<string, modelserver.Node> nodes = 2;
   */
  nodes: { [key: string]: Node } = {};

  /**
   * @generated from field: repeated modelserver.Edge edges = 3;
   */
  edges: Edge[] = [];

  /**
   * @generated from field: map<string, modelserver.Agent> agents = 4;
   */
  agents: { [key: string]: Agent } = {};

  constructor(data?: PartialMessage<Model>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.Model";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tick", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "nodes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Node} },
    { no: 3, name: "edges", kind: "message", T: Edge, repeated: true },
    { no: 4, name: "agents", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Agent} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Model {
    return new Model().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJsonString(jsonString, options);
  }

  static equals(a: Model | PlainMessage<Model> | undefined, b: Model | PlainMessage<Model> | undefined): boolean {
    return proto3.util.equals(Model, a, b);
  }
}

/**
 * @generated from message modelserver.Node
 */
export class Node extends Message<Node> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: map<string, modelserver.MarketInfo> markets = 2;
   */
  markets: { [key: string]: MarketInfo } = {};

  /**
   * @generated from field: repeated string links = 3;
   */
  links: string[] = [];

  constructor(data?: PartialMessage<Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "markets", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: MarketInfo} },
    { no: 3, name: "links", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node {
    return new Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJsonString(jsonString, options);
  }

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean {
    return proto3.util.equals(Node, a, b);
  }
}

/**
 * @generated from message modelserver.Agent
 */
export class Agent extends Message<Agent> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string cargo = 2;
   */
  cargo = "";

  /**
   * @generated from field: string location = 3;
   */
  location = "";

  /**
   * @generated from field: double money = 4;
   */
  money = 0;

  constructor(data?: PartialMessage<Agent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.Agent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cargo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "money", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Agent {
    return new Agent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Agent {
    return new Agent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Agent {
    return new Agent().fromJsonString(jsonString, options);
  }

  static equals(a: Agent | PlainMessage<Agent> | undefined, b: Agent | PlainMessage<Agent> | undefined): boolean {
    return proto3.util.equals(Agent, a, b);
  }
}

/**
 * @generated from message modelserver.Edge
 */
export class Edge extends Message<Edge> {
  /**
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * @generated from field: string to = 2;
   */
  to = "";

  constructor(data?: PartialMessage<Edge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.Edge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Edge {
    return new Edge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Edge {
    return new Edge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Edge {
    return new Edge().fromJsonString(jsonString, options);
  }

  static equals(a: Edge | PlainMessage<Edge> | undefined, b: Edge | PlainMessage<Edge> | undefined): boolean {
    return proto3.util.equals(Edge, a, b);
  }
}

/**
 * @generated from message modelserver.MarketInfo
 */
export class MarketInfo extends Message<MarketInfo> {
  /**
   * @generated from field: double supply = 1;
   */
  supply = 0;

  /**
   * @generated from field: double consumption = 2;
   */
  consumption = 0;

  /**
   * @generated from field: double production = 3;
   */
  production = 0;

  /**
   * @generated from field: double price = 4;
   */
  price = 0;

  constructor(data?: PartialMessage<MarketInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.MarketInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "supply", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "consumption", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "production", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketInfo {
    return new MarketInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketInfo {
    return new MarketInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketInfo {
    return new MarketInfo().fromJsonString(jsonString, options);
  }

  static equals(a: MarketInfo | PlainMessage<MarketInfo> | undefined, b: MarketInfo | PlainMessage<MarketInfo> | undefined): boolean {
    return proto3.util.equals(MarketInfo, a, b);
  }
}

/**
 * @generated from message modelserver.RGraph
 */
export class RGraph extends Message<RGraph> {
  /**
   * @generated from field: map<string, modelserver.RNode> nodes = 1;
   */
  nodes: { [key: string]: RNode } = {};

  /**
   * @generated from field: repeated modelserver.Edge edges = 2;
   */
  edges: Edge[] = [];

  constructor(data?: PartialMessage<RGraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.RGraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: RNode} },
    { no: 2, name: "edges", kind: "message", T: Edge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RGraph {
    return new RGraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RGraph {
    return new RGraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RGraph {
    return new RGraph().fromJsonString(jsonString, options);
  }

  static equals(a: RGraph | PlainMessage<RGraph> | undefined, b: RGraph | PlainMessage<RGraph> | undefined): boolean {
    return proto3.util.equals(RGraph, a, b);
  }
}

/**
 * @generated from message modelserver.RNode
 */
export class RNode extends Message<RNode> {
  /**
   * @generated from field: int32 x = 1;
   */
  x = 0;

  /**
   * @generated from field: int32 y = 2;
   */
  y = 0;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: float radius = 4;
   */
  radius = 0;

  constructor(data?: PartialMessage<RNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.RNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "y", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "radius", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RNode {
    return new RNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RNode {
    return new RNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RNode {
    return new RNode().fromJsonString(jsonString, options);
  }

  static equals(a: RNode | PlainMessage<RNode> | undefined, b: RNode | PlainMessage<RNode> | undefined): boolean {
    return proto3.util.equals(RNode, a, b);
  }
}

/**
 * @generated from message modelserver.SaveFormat
 */
export class SaveFormat extends Message<SaveFormat> {
  /**
   * @generated from field: map<uint64, modelserver.Model> models = 1;
   */
  models: { [key: string]: Model } = {};

  /**
   * @generated from field: modelserver.RGraph visual = 2;
   */
  visual?: RGraph;

  constructor(data?: PartialMessage<SaveFormat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "modelserver.SaveFormat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "models", kind: "map", K: 4 /* ScalarType.UINT64 */, V: {kind: "message", T: Model} },
    { no: 2, name: "visual", kind: "message", T: RGraph },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SaveFormat {
    return new SaveFormat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SaveFormat {
    return new SaveFormat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SaveFormat {
    return new SaveFormat().fromJsonString(jsonString, options);
  }

  static equals(a: SaveFormat | PlainMessage<SaveFormat> | undefined, b: SaveFormat | PlainMessage<SaveFormat> | undefined): boolean {
    return proto3.util.equals(SaveFormat, a, b);
  }
}

